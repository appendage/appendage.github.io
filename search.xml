<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Debian下安装Docker]]></title>
    <url>%2F2017%2F06%2F08%2Fdocker%2F</url>
    <content type="text"><![CDATA[Docker有两个版本：社区版（CE)和企业版(EE)。 先决条件Docker EE用户Debian不支持Docker EE。 操作系统要求要安装Docker,您需要64为版本的Debian或Raspbian版本之一： Stretch(testing) jessie 8.0(LTS) / Raspbian jessie Wheezy 7.7(LTS) 内核版本至少3.10 Docker支持x86_64和armhf架构的jessie和Stretch 卸载旧版本较老版本的Docker被称为docker或docker-engine。如果这些已安装，请卸载它们：$ apt-get remove docker docker-engine 安装Docker CE您可以根据需要以不同的方式安装Docker CE： 大多数用户 设置了Docker的存储库并从中安装，以方便安装和升级任务。这是推荐的方法。 一些用户下载DEB软件包并手动安装并手动管理升级。这在没有访问互联网的系统上安装Docker的情况下是有用的。 使用存储库安装在新主机上首次安装Docker CE之前，需要设置Docker存储库。之后，可以从存储库安装和更新 设置存储库 安装软件以允许apt通过HTTPS使用存储库： jessie或Stretch: $ apt-get install \apt-transport-https \ca-certificates \curl \gnupg2 \software-properties-common` Wheezy: $ apt-get install \apt-transport-https \ca-certificates \curl \python-software-properties 添加Docker的官方GPG密钥： $ curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add - 验证密钥ID是否9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。 $ apt-key fingerprint 0EBFCD88pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid Docker Release (CE deb) &lt;docker@docker.com&gt;sub 4096R/F273FCD8 2017-02-22 使用以下命令设置stable版本库 am64: $ add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian \$(lsb_release -cs) \stable" armhf: $ echo "deb [arch=armhf] https://download.docker.com/linux/debian \$(lsb_release -cs) stable" | \sudo tee /etc/apt/sources.list.d/docker.list 仅限Wheezy：Wheezy的版本add-apt-repository添加了deb-src 不存在的存储库。您需要注释掉该存储库或运行apt-get update将失败。编辑/etc/apt/sources.list。找到如下所示的行，并将其注释掉或删除它： deb-src [arch=amd64] https://download.docker.com/linux/debian wheezy stable 安装DOCKER CEapt-get updateapt-get install docker-ce 警告：如果启用了多个Docker存储库，则无需在apt-get install 或 apt-get update,命令中指定版本即可安装或更新，将始终安装尽可能高的版本，这可能不适合您的稳定性需求。 在生产系统上，您应该安装特定版本的Docker，而不是始终使用最新版本。此输出被截断。列出可用版本：$ apt-cache madison docker-cedocker-ce | 17.03.0~ce-0~debian-jessie | https://download.docker.com/linux/debian jessie/stable amd64 Packages 列表的内容取决于启用了哪些存储库，并且将特定于您的Debian jessie 版本（在该示例中由版本的后缀指示）。选择要安装的特定版本。第二列是版本字符串。第三列是存储库名称，它指示软件包所在的存储库以及其稳定性级别。要安装特定版本，请将版本字符串附加到程序包名称，并使用等号（=）分隔：$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; Docker守护进程自动启动 DEB包离线安装如果您不能使用Docker的存储库来安装Docker CE，则可以下载该.deb版本的 文件并手动安装。每次要升级Docker时，都需要下载一个新文件。 转到https://download.docker.com/linux/debian/dists/，选择您的Debian版本，浏览stable/pool/stable/，选择amd64或选择 要安装的Docker版本的.deb文件，以及您要安装的Debian版本的文件。 安装Docker CE,将下面的路径更改为您下载Docker程序包的路径dpkg -i /path/to/package.deb Docker守护进程程序自动启动。 卸载Docker 卸载Docker软件包： apt-get purge docker-ce 主机上的图像，容器，卷或自定义配置文件不会自动删除。删除所有图像，容器和卷： rm -rf /var/lib/docker]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（guacamole+tomcat）安装]]></title>
    <url>%2F2017%2F05%2F31%2Fguacamole_install%2F</url>
    <content type="text"><![CDATA[guacamole服务端安装所需依赖 必须安装的库Cairo libjpeg-turbo libpng “OSSP UUID” apt-get -y --allow install libcairo2-dev \libjpeg62-dev libpng12-dev libossp-uuid-dev 可选依赖 可选库：FreeRDP、Pango、libssh2、libtelnet、libVNCServer、PulseAudio、OpenSSL、libvorbis、libwebp apt-get -y --allow install libfreerdp-dev libpango1.0-dev \libssh2-1-dev libtelnet-dev libvncserver-dev libpulse-dev \libssl-dev libvorbis-dev libwebp-dev 获取源代码从Guacamole项目网站获取$ tar -xzf guacamole-server-0.9.12-incubating.tar.gz$ cd guacamole-server-0.9.12-incubating/$ 如果想要最新的代码，并且不关心稳定性，可以从github上克隆：$ git clone git://github.com/apache/incubator-guacamole-server.gitCloning into 'incubator-guacamole-server'...remote: Counting objects: 6769, done.remote: Compressing objects: 100% (2244/2244), done.remote: Total 6769 (delta 3058), reused 6718 (delta 3008)Receiving objects: 100% (6769/6769), 2.32 MiB | 777 KiB/s, done.Resolving deltas: 100% (3058/3058), done.$ 构建过程 如果是从git直接下载的源代码不会包含configure脚本，需要手动生成：$ cd guacamole-server/$ autoreconf -fi这样做需要安装GNU Autotools. ./configure --with-init-dir=/etc/init.d checking for a BSD-compatible install... /usr/bin/install -cchecking whether build environment is sane... yes...------------------------------------------------guacamole-server version 0.9.12-incubating------------------------------------------------ Library status: freerdp ............. yes pango ............... yes libavcodec .......... yes libavutil ........... yes libssh2 ............. yes libssl .............. yes libswscale .......... yes libtelnet ........... yes libVNCServer ........ yes libvorbis ........... yes libpulse ............ yes libwebp ............. yes Protocol support: RDP ....... yes SSH ....... yes Telnet .... yes VNC ....... yes Services / tools: guacd ...... yes guacenc .... yes Init scripts: /etc/init.dType "make" to compile guacamole-server.$ make 安装make installldconfig guacamole客户端tomcat安装 下载安装对应的jdk,并配置java环境。 mkdir /usr/local/java/cd /usr/local/javatar -zxvf jdk-8-linux-x64.tar.gz 配置环境变量 vim /etc/profileJAVA_HOME=/usr/local/java/jdk1.8.0_25CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jarGUACAMOLE=/etc/guacamolePATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH GUACAMOLE 配置生效source /etc/profile 安装tomcat包 mkdir /usr/local/tomcattar -zxvf apache-tomcat-8.tar.gzmv apache-tomcat-8 /usr/local/tomcat 将guacamole.war 放到webapps 启动tomcat/usr/local/tomcat/bin/catalina.sh start]]></content>
      <categories>
        <category>系统运维</category>
      </categories>
      <tags>
        <tag>guacamole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker搭建tomcat环境]]></title>
    <url>%2F2017%2F05%2F04%2Fdocker_tomcat%2F</url>
    <content type="text"><![CDATA[$ mkdir tomcat #新建tomcat文件夹 进入tomcat文件夹，下载apache-tomcat-7.0.77.tar.gz和jdk-8u131-linux-x64.tar.gz$ vim Dockerfile #新建Dockerfile构建镜像 FROM debian:7 #基础镜像为debian7 MAINTAINER JiaHan &lt;jh_jiahan@163.com&gt; ENV REFRESHED 2017-05-04 ADD apache-tomcat-7.0.77.tar.gz /usr/local/ ADD jdk-8u131-linux-x64.tar.gz /usr/local/java/ ENV JAVA_HOME /usr/local/java/jdk1.8.0_131 ENV JRE_HOME /usr/local/java/jdk1.8.0_131/jre ENV CLASSPATH .:$JAVA_HOME/lib:$JRE_HOME/lib ENV PATH $PATH:$JAVA_HOME/bin ENV CATALINA_HOME /usr/local/apache-tomcat-7.0.77 EXPOSE 8080 CMD ["/usr/local/apache-tomcat-7.0.77/bin/catalina.sh","run"]$ docker build -t docker_tomcat7$ docker images docker_tomcat7 #查看新镜像$ docker run -d -p 8080:8080 --name tomcat7 docker_tomcat7 #-p 将容器端口8080映射到宿主机8080测试 ：使用浏览器访问宿主机8080端口 运行自己的Docker Registry$ docker run -p -d -v /root/registry:/var/lib/registry --name registry 5000：5000 registry:2 提交的镜像文件默认保存在Registry容器的/var/lib/registry,将宿主机/root/registry挂载到此目录，镜像文件就保存在宿主机的/root/registry下了 提交tomcat镜像到自己的Docker Registry$ docker tag docker_tomcat7 localhost:5000/docker_tomcat7$ docker push localhost:5000/docker_tomcat7 执行以上语句有很大可能会报错，解决办法 echo -e “DOCKER_OPTS=\”–insecure-registry localhost:5000\”” &gt;&gt;/etc/default/docker echo -e “{ \”insecure-registries\”:[\”localhost:5000\”] }” &gt;&gt;/etc/docker/daemon.json #新建此文件从本地Registry构建新的镜像$ docker run -t -i localhost:5000/docker_tomcat7 /bin/bash]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2017%2F05%2F02%2Fdocker_command%2F</url>
    <content type="text"><![CDATA[&lt;name or id&gt; 容器的名称和id Docker安装Ubuntu和Debian中安装 ATP源更新为阿里源 $ vim /etc/apt/sources.list&nbsp;&nbsp;&nbsp;&nbsp;deb http://mirrors.aliyun.com/debian/ jessie main non-free contrib&nbsp;&nbsp;&nbsp;&nbsp;deb http://mirrors.aliyun.com/debian/ jessie-proposed-updates main non-free contrib&nbsp;&nbsp;&nbsp;&nbsp;deb-src http://mirrors.aliyun.com/debian/ jessie main non-free contrib&nbsp;&nbsp;&nbsp;&nbsp;deb-src http://mirrors.aliyun.com/debian/ jessie-proposed-updates main non-free contrib$ apt-get update $$ apt-get install docker-engine -y RedHat系列版本安装CENTOS7为例 $ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo$ yum makecache Docker安装脚本curl https://get.docker.com/ | sh 二进制安装包里包含docker二进制文件，将解压出docker文件添加到环境变量就能运行docker命令。wget http://get.docker.com/builds/Linux/x86_64/docker-latest.tgz Docker守护进程网络安装的方法，在安装完成之后会自动已守护进程方式运行Dockerdocker daemon Docker 入门创建容器docker create --restart=always -i -t --name test_docker debian:7 #只创建容器docker run --restart=always -i -t --name test_docker debian:7 #创建并运行容器 参数说明 –restart always 无论容器的退出代码是什么，Docker都会自动重启该容器 on-failure 只有容器的退出代码为非0时，才会自动重启(非正常退出) on-failure:5 重启次数 -i 容器的STDIN是开启的 -t 为要创建的容器分配一个伪终端 -i -t 同时使用 新创建的容器能提供一个交互式shell –name 为容器指定一个名称 debian:7 如果本地没有debian7镜像，会自动下载 查询容器docker ps #正在运行的容器docker ps -a #全部容器docker inspect &lt;name or id&gt;#查询容器的详细信息 删除容器docker rm &lt;name or id&gt; 启动、停止、重启容器docker start &lt;name or id&gt; #启动容器docker restart &lt;name or id&gt; #重新启动容器docker stop &lt;name or id&gt; #停止容器 Docker维护命令docker attach &lt;name or id&gt; #进入到容器（可能需要按enter）docker logs --tail 10 -ft &lt;name or id&gt; #查询容器日志# -t 加入时间戳docker top &lt;name or id&gt; #查询容器内的进程docker stats &lt;name or id&gt; &lt;name or id&gt; #cpu/内存/网络IO/存储IO信息，可以同时查看多个容器docker exec -d test_docker touch /root/test #在容器内部运行进程 ###使用Docker镜像和仓库docker search &lt;service&gt; #搜索service镜像docker pull &lt;service&gt; #拉取service镜像docker login #登录docker images #查询本地镜像]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyinotify：在 Linux 中实时监控文件系统更改]]></title>
    <url>%2F2017%2F04%2F28%2Fpyinotify%2F</url>
    <content type="text"><![CDATA[依赖Linux kernel &gt;= 2.6.13 Python &gt;=2.4 Linux安装pyinotifygit clone https://github.com/seb-m/pyinotify.git cd pyinotify python setup.py install 使用python -m pyinotify -v /usr/local/tomcat#监控/usr/local/tomcat目录变化，这样日志会输出到当前控制台nohup -m pyinotify -v /usr/local/tomcat &gt;/var/log/pyinotify.log &amp;#记录到文件并进程后台运行]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyinotify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闲来无事，django创建登录界面]]></title>
    <url>%2F2017%2F04%2F27%2Fdjango%2F</url>
    <content type="text"><![CDATA[环境Debian 7.5 Python 3.6.1 Django 1.11 mysql 5.5.47 安装配置配置网络源为阿里源vim /etc/apt/sources.list deb http://mirrors.aliyun.com/debian/ wheezy main non-free contrib deb http://mirrors.aliyun.com/debian/ wheezy-proposed-updates main non-free contrib deb-src http://mirrors.aliyun.com/debian/ wheezy main non-free contrib deb-src http://mirrors.aliyun.com/debian/ wheezy-proposed-updates main non-free contrib 源码安装python3.6.1tar -zxvf Python-3.6.1.tgzcd Python-3.6.1./configure #默认安装在/usr/local/bin下make &amp;&amp; make install mv /usr/local/bin/python3.6 /usr/bin/python #将默认的python2.7更改为python3.6 源码安装Django1.11tar -zxvf Django-1.11.tar.gzcd Django-1.11python setup.py install mysql安装(使用的网络源安装)apt-get install mysql-server 创建web库并使用utf8编码，否则有可能中文乱码(登录mysql后执行)CREATE DATABASE web DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 安装PyMySQLgit clone https://github.com/PyMySQL/PyMySQL.gitcd PyMySQL &amp;&amp; python setup.py installvim web/web/__init__.py #python3不支持MySQLdb,用pymysql来代替 import pymysql pymysql.install_as_MySQLdb() 开始编码code……创建项目webdjango-admin startproject web 创建app#进入项目目录python manager startapp login 激活模型编辑web/settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'login',]ALLOWED_HOSTS = ['*'] #允许所有用户访问TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': ['login/templates'], #定义templates路径 'APP_DIRS': True, 'OPTIONS': &#123; …… models模型编辑login/models.py，创建数据库表结构from django.db import models# Create your models here.class Person(models.Model): user = models.CharField(max_length=30) password = models.CharField(max_length=30) def __unicode(self): return self.user #返回的对象名，默认为Object Django数据类型https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.FileField 自定义models模型创建login/forms.pyfrom django import formsclass LoginForm(forms.Form): user = forms.CharField() password = forms.CharField()class RegisterForm(forms.Form): user = forms.CharField() password = forms.CharField() 在数据库中创建表python manage.py migrate URL配置创建login/urls.py,配置登录界面和注册界面URLfrom django.conf.urls import urlfrom django.contrib import adminfrom login import viewsurlpatterns = [ url(r'^login/', views.login, name='login'), url(r'^register/', views.register, name='register'),] views实现功能from django.shortcuts import renderfrom django.http import HttpResponsefrom login.models import Personfrom .forms import LoginFormfrom .forms import RegisterFormfrom django.contrib import messages# Create your views here.def login(request): if request.method == 'POST': form = LoginForm(request.POST) if form.is_valid(): user = form.cleaned_data['user'] password = form.cleaned_data['password'] reluser = Person.objects.get(user=user).user relpwd = Person.objects.get(user=user).password #return render(request, 'test.html',&#123;'user':user,'password':password,'reluser':reluser&#125;) if user==reluser and password == relpwd: #messages.success(request,'登录成功') ret = "登录成功" return render(request, 'test.html',&#123;'user':user,'password':password,'ret':ret&#125;) else: #messages.success(request,'登录失败') ret = "登录失败，密码错误！" return render(request, 'test.html',&#123;'ret':ret&#125;) else: form = LoginForm() return render(request, 'login.html', &#123;'form':form&#125;)def register(request): if request.method == 'POST': form = RegisterForm(request.POST) if form.is_valid(): user = form.cleaned_data['user'] password = form.cleaned_data['password'] Person.objects.create(user=user,password=password) #messages.success(request,'注册成功') ret = "注册成功" return render(request, 'test.html',&#123;'ret':ret&#125;) else: form = RegisterForm() return render(request, 'register.html', &#123;'form':form&#125;) templates文件创建login/templates,并新建login.html,register.html,test.html login.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="Login.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="login"&gt; &lt;h1&gt;Login&lt;/h1&gt; &lt;form method="post"&gt; &#123;% csrf_token %&#125; &lt;!--防跨标签--&gt; &#123;&#123; form &#125;&#125; &lt;input type="submit" value="登录"&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; resiter.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;register&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="Login.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="login"&gt; &lt;form method="post"&gt; &#123;% csrf_token %&#125; &lt;!--防跨标签--&gt; &#123;&#123; form &#125;&#125; &lt;input type="submit" value="确认注册"&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; test.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="Login.css"/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="login"&gt; &#123;&#123; ret &#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 简单的登录界面就这样实现了，没有任何检测机制。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pacemaker+Heartbeat(双机tomcat+mysql)]]></title>
    <url>%2F2017%2F04%2F21%2Fpacemaker%2F</url>
    <content type="text"><![CDATA[Heartbeat安装依赖包#cd到heartbeat依赖包目录执行dpkg -i *.deb #如果报错,再次执行一次 安装Heartbeatdpkg -i heartbeat_3.0.5-3_amd64.deb 配置Heartbeatha.cf#记录所有non-debug消息，如果启用use_logd，则此选项会被忽略logfile /var/log/ha-log#告诉heartbeat记录那些sysloglogfacility local0#如果udpport指令在bcast ucast指令的前面，则使用哪个端口进行广播，否则使用默认端口udpport 694#设置使用哪个网络接口进行UDP单播心跳检测ucast eth0 172.16.100.82#设置ping节点，ping节点用来检测网络连接ping 172.16.100.3#多久以后心跳检测决定集群中的node已经挂掉deadtime 3#在heartbeat启动后，在多长时间内宣布node是dead状态，因为有时候系统启动后，网络还需要一段时间才能启动initdead 10#指定两个心跳检测包的时间间隔keepalive 1#告诉集群中有哪些节点(主机名 uname -a)node fort1node fort2#在主节点的服务恢复后，是否把从节点的服务切换回来auto_failback off#开启Pacemaker cluster managerpacemaker respawn authkeysauth11 sha1 tomcat Pacemaker安装依赖包#cd到pacemaker依赖包目录dpkg -i *.deb 安装Pacemakerdpkg -i pacemaker_1.1.7-1_amd64.deb 配置Pacemakercrm configure property stonith-enabled=falsecrm configure property no-quorum-policy=ignorecrm configure property start-failure-is-fatal=falsecrm configure rsc_defaults migration-threshold=1crm configure rsc_defaults failure-timeout=60crm configure primitive vip ocf:heartbeat:IPaddr2 params ip=172.16.100.80 nic=eth0 cidr_netmask=32 op start interval=0 timeout=10 op stop interval=0 timeout=10 op monitor interval=10 timeout=10 start-delay=0crm configure primitive www lsb:tomcat op start interval=0 timeout=10 op stop interval=0 timeout=10 op monitor interval=10 start-delay=0crm configure primitive mysql lsb:mysql1 op start interval=0 timeout=10 op stop interval=0 timeout=10 op monitor interval=10 start-delay=0crm configure group group1 vip wwwcrm configure location loc_tomcat_fort1 www 3: fort1crm configure location loc_mysql_fort1 www 3: fort1crm configure location loc_tomcat_fort2 mysql 2: fort2crm configure location loc_mysql_fort2 mysql 2: fort2 配置说明crm configure property stonith-enabled=false #如果没有stonith资源,必须设置为falsecrm configure property no-quorum-policy=ignore#如果是两个节点必须设置为ignore，否则不能正常运行crm configure property start-failure-is-fatal=false #允许设置下面参数crm configure rsc_defaults migration-threshold=1#节点上的此资源应发生多少故障后才能确定该节点没有资格主管此资源crm configure rsc_defaults failure-timeout=60 #恢复故障crm configure primitive vip ocf:heartbeat:IPaddr2 params ip=172.16.100.80 nic=eth0 cidr_netmask=32 op start interval=0 timeout=10 op stop interval=0 timeout=10 op monitor interval=10 timeout=10 start-delay=0 #添加VIP资源 crm configure primitive www lsb:tomcat op start interval=0 timeout=10 op stop interval=0 timeout=10 op monitor interval=10 start-delay=0#添加tomcat资源crm configure group group1 vip www #将资源和VIP绑定到一起crm configure location loc_tomcat_fort1 www 3: fort1 设置fort1主机Tomcat分值为3crm configure location loc_mysql_fort1 mysql 3: fort1设置fort1主机Mysql分值为3crm configure location loc_tomcat_fort2 tomcat 2: fort2设置fort2主机Tomcat分值为2crm configure location loc_mysql_fort2 mysql 2: fort2设置fort2主机Mysql分值为2节点资源分值相加，VIP优先在分值大的节点上。]]></content>
      <categories>
        <category>集群</category>
      </categories>
      <tags>
        <tag>Pacemaker</tag>
      </tags>
  </entry>
</search>